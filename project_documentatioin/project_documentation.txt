
Для реализации данного проекта с учетом объема входящих данных:

- 	выбрал абстрактуную структуру данных Adjacency List;

- 	вершины хранятся в контейнере std::unordered_map, поскольку у него О(1) по операциям добавления, поиска, удаления;
	также протестировал контейнеры std::vector && std::list, std::unordered_map занимает меньше места в памяти по сравнению с ними;

-	для хранения граней использовал std::list, посколько по специфек работе с гранями, при добавлении в голову списка, сложность операции добавления составляет О(1) и данный контейнер
	предназначен для вывода содержащихся в нем данных последовательно - О(n);


Архитектура проекта состоит из последовательных этапов:

1. Class Lexer		-> Лексический анализ входящих данных по нижеследующим параметрам:

	- полное соответствие формату входящей строки, к примеру: в строках 15 и 2509 присутствует ошибка 
	в определении типа узла - CA-SW; регулярное выражение, на основе которого проходил анализ входящей строки,
	находится: ../includes/lexer.cpp, строка № 16;

	- все неуникальные вершины были отсеяны посредством свойства контейнера std::unordered_map не принимать повторяющиеся значения;

	- также присутсвует проверка, что SW может соединятся с SW, RT, (HCA == CA) только;

2. Class Parser 	-> размещает согласно логики построения графа входящие данные в памятьж

3. Class Database 	-> выступает схемой памяти графа;

4. Class Vertex 	-> описывает данный, которые хранятся в узле графа;

5. Class Visualizer -> осуществляет визуализацию данных;

6. Class Core		-> инкапсулирует вышеописанную логику;

7. main.cpp			-> запуск процесса;