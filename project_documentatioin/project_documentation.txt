
Для реализации данного проекта с учетом объема входящих данных:

- 	выбрал абстрактуную структуру данных Adjacency List для построения ненаправленного графа;

- 	вершины хранятся в контейнере std::unordered_map, поскольку у данного контейнера сложность по операциям добавления, поиска, удаления - О(1);
	также протестировал контейнеры std::vector && std::list, std::unordered_map занимает меньше места в памяти по сравнению с ними и работает быстрее (hash - table type container);

-	для хранения граней использовал std::list, поскольку по специфек работе с гранями данного решения, при добавлении в голову списка, сложность операции добавления составляет О(1) и данный контейнер
	предназначен для вывода содержащихся в нем данных последовательно - О(n);


Архитектура проекта состоит из последовательных этапов:

1. Class Lexer		-> 	Лексический анализ входящих данных по нижеследующим параметрам:

	- полное соответствие формату входящей строки, к примеру: в строках 15 и 2509 присутствует ошибка 
	в определении типа узла - CA-SW; регулярное выражение, на основе которого проходил анализ входящей строки,
	находится: ../includes/lexer.cpp, строка № 16;

	- все неуникальные вершины были отсеяны посредством свойства контейнера std::unordered_map не принимать повторяющиеся значения;

	- также присутсвует проверка, что SW может соединятся с SW, RT, (HCA == CA) только;

2. Class Parser 	-> 	размещает, согласно логики построения графа, входящие данные в памятьж

3. Class Database 	-> 	выступает схемой памяти графа;

4. Class Vertex 	-> 	описывает данные, которые хранятся в узле графа;
						данные были сохранены в класс std::string с целью созранения памяти; целочисленный типы данных больше занимают памяти;
						в случае необходимости, данные строки можно конвертировать посредством семейства функций std::stod, std::stold и т.д.;

5. Class Visualizer -> 	осуществляет визуализацию данных;
	
6. Class Core		-> 	инкапсулирует вышеописанную логику;
						функции визуализации инкапсулированы данным класом и вызываются посредством массива указателей на функции,
						строки в файле ../source.core.cpp - [95 - 102];

7. main.cpp			-> 	запуск процесса;

Программа была протестирована на присутствие утечек памяти командой - system("leaks -q infiniBand_network_graph") нв MacOS High Sierra 10.13.3. 

Утечки папяти отсутствуют.

Makefile поддерживает компиляцию на вышеуказанной MacOs и Ubuntu 16.04

Спасибо и заранее благодарю за комментарии.

С уважением,
Алексей
